# This project
* Move graphics constants to separate file
* Move world constants to separate file

* 3rd person camera

* Bounding shapes
* EntityType enum for intersection
* Intersections
        - detection
        - resolution
        - response (container of collision info)

* Get opacity to work
* Program objects
* Make things protected
* Callback names
        - onTick
        - onDraw
        - onCollide

# Next project
* Entity types
        - Passive, active
* Errors
* Bounding shapes have actually shapes if debug is turned on
    - Actual bounding object collision.

# Questions
* Is this model generalizable to different types of games?
* Is this model easy / does it make sense to use?
* Is this model this be easy to extend?
* Is active entity vs. passive entity a good paradigm?

# Answered Questions
* Where is the injection point for game code?
        - Applcation
* How would someone go about creating a game using this framework?
        - Extend the screen class
        - Instantiate application
        - Set the view's application
        - Instantiate screens, and add them to the application

        - Set up graphics controllers with textures and programs
        - Add graphics controllers to the screens

        - Insantiate scene classes
        - Extend shape classes
        - Extend entity classes
        - Instantiate lights
        - Add shapes and entities and lights to the scene

        - Override entity collide methods
        - Override screen update methods, setting uniforms, etc.
                * This part can be improved by abstracting programs
